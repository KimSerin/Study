상속이 아닌 조립을 사용해야 하는 이유
1. 변경의 유연함이 떨어진다
 1-1. 상위 클래스 변경의 어려움
  - 상속계층을 따라 상위 클래스의 변경이 하위 클래스에 영향을 줌
 1-2. 클래스의 불필요한 증가
  - 필요한 조합이 생길때마다 클래스 생성 필요
 1-3 상속의 오용
  - 부모 클래스의 기능을 잘못 사용할 가능성
2. 조립을 사용할 경우?
 2-1. 필요한 기능이 추가되더라도 클래스가 추가되지 않는다. 조립으로 추가하면 됨
 2-2. 런타임 시 조립대상 객체를 교체 가능

-> 가능하면 조립을 사용하고, 상속은 명확한 IS-A 관계인 경우 사용


설계원칙: SOLID
1. 단일 책임 원칙(Single responsibility principle)
 - 클래스는 단 한개의 책임을 가져야 한다.
  : 책임의 개수가 많아질수록 한 책임의 변화가 다른 책임에 주는 영향이 비례하여 증가하기 때문
2. 개방 폐쇄 원칙(Open-closed principle)
 - 기능을 변경하거나 확장가능하나, 그 기능을 사용하는 코드는 수정하지 않는다.
  : 구현 가능 이유는 확장되는 부분(변화되는 부분)을 추상화 하여 표현했기 때문
  : 변화가 예상되는 것을 추상화하여 변경의 유연함을 얻도록 한다.
  : 코드에 대한 변화 요구가 발생하면, 변화와 관련된 구현을 추상화해서 개방 폐쇄 원칙에 맞게 수정 가능한지 확인
3. 리스코프 치환 원칙(Liskov substitution principle)
 - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
  : instanceof를 사용하는 것 자체가 리스코프 법칙 위반(새로운 종류의 하위타입이 생길 때마다 상위 타입을 수정해야 하는 가능성이 높아짐)
  : 하위 타입은 상위 타입에서 정의한 명세를 벗어나지 않는 범위에서 구현해야 한다.(리턴값, 익셉션, 기능 등)
  : 리스코프 치환을 어기게 되는 이유는 상위 클래스에 대한 추상화가 덜 이루어 졌기 때문...
4. 인터페이스 분리 원칙(Interface segregation principle)
 - 클라이언트는 자신이 사용하는 메서드에만 의존해야 한다.
  : 하나의 header를 여러 UI가 의존할 경우 header가 변경되었을때 의존하고 있는 모든 UI를 재빌드 해야 한다.
  : 용도에 맞게 인터페이스를 분리하는 것은 단일 책임 원칙과도 연결
  : 클라이언트 입장에서 인터페이스를 분리하는 것
5. 의존 역전 원칙(Dependency inversion principle)
 - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상타입에 의존해야 한다.
  : 저수준 모듈이 변경되더라도 고수준 모듈은 변경되지 않는다.
  : 런타임의 의존이 아닌 소스 코드의 의존을 역전시킴으로써 변경의 유연함을 확보할 수 있도록 하는 원칙
    (런타임에서의 의존과 소스 코드의 의존을 구분)
  : 의존 역전 원칙은 타입의 소유도 역전시킨다. 타입의 소유 역전은 각 패키지를 독립적으로 배포할 수 있도록 만들어 준다.(jar, dll 등)


주요 디자인 패턴
1. 전략(Strategy) 패턴
 - 알고리즘을 추상화하고 있는 클래스를 전략(Strategy)라고 부르고, 기능 자체의 책임을 갖고 있는 클래스를 Context라고 부르는데,
   이렇게 특정 콘텍스트에서 알고리즘(전략)을 별도로 분리하는 설계 방법이 전략 패턴이다.
  : 정책이 추가될 때마다 객체를 추가
  : 콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다
  : 전략의 콘크리트 클래스와 클라이언트의 코드가 쌍을 이루기 때문에 유지 보수 문제가 발생할 가능성이 줄어든다.
  : 완전히 동일한 기능을 제공하지만, 성능의 장단점에 따라 알고리즘을 선택해야 하는 경우 전략 패턴이 사용된다.
  
2. 템플릿 메서드(Template Method) 패턴
 - 동일한 절차를 가진 메서드들을 추상화한 메서드를 템플릿 메서드라 한다.
  : 동일한 실행과정의 구현을 제공하면서 동시에 하위 타입에서 일부 단계를 구현하도록 할 수 있다.(코드중복 방지)
  : 두가지로 구성된다. 1. 실행과정을 구현한 상위 클래스 2. 실행 과정의 일부를 구현한 하위 클래스

*훅메서드
 - 상위 클래스에서 기본구현을 제공하면서, 하위 클래스에서 알맞게 확장할 수 있는 메서드를 훅 메서드라 한다.
  : ex) 템플릿 메서드에서 추상메서드를 사용->하위클래스에서 확장시킬 수 있음

* 템플릿 메서드+전략패턴
 - 상속을 이용하는 대신 전략 패턴과 같이 하위 객체를 DI(의존주입)로 받아 실행하면 템플릿 메서드보다 유연함을 가지게 된다. 

3. 상태(State) 패턴
 - 